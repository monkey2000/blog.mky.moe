---
layout: post
title: "MIT 6.828 - 7. Lab 07: Locks"
date: 2020-02-07 12:54
tags:
    - MIT 6.828
---

ðŸ•¯ ä»Šæ—¥å‡Œæ™¨å¬è¯´æ­¦æ±‰è‚ºç‚Žçš„ Whistleblower æŽæ–‡äº®å› ä¸ºä¸æ²»åŽ»ä¸–äº†ï¼Œå†æ¬¡ç¼…æ€€ã€‚

è¦æ˜¯ä¸­å›½ä¹Ÿæœ‰ Whistleblower Protection Act å°±å¥½äº†ï¼Œè‡³å°‘ä½¿è‹±é›„é…å¾—ä¸Šè¢«äººä»¬ç¼…æ€€ï¼Ÿ

# å®žéªŒæ€»ç»“

1. æœ¬æ¬¡å®žéªŒç”¨æ—¶çº¦ 3 ä¸ªå°æ—¶ã€‚
2. æ”¶èŽ·æ˜¯å¯¹ç±» UNIX æ–‡ä»¶ç³»ç»Ÿçš„å¤šå±‚æŠ½è±¡è®¤è¯†æ›´æ·±å…¥äº†ã€‚

å®žéªŒç»“æŸåŽçš„å…¨éƒ¨ä»£ç åœ¨ï¼šhttps://github.com/monkey2000/xv6-riscv/tree/fs/

æµ‹è¯•ç»“æžœï¼š
```bash
running bigfile: 
$ make qemu-gdb
OK (98.2s) 
running symlinktest: 
$ make qemu-gdb
(0.7s) 
  symlinktest: symlinks: OK 
  symlinktest: concurrent symlinks: OK 
usertests: 
$ make qemu-gdb
OK (160.6s) 
time: OK 
Score: 100/100
```

# 0. å®žéªŒå‡†å¤‡

[å®žéªŒæŒ‡å¯¼é“¾æŽ¥](https://pdos.csail.mit.edu/6.828/2019/labs/fs.html)


ä¸Šæ¥ç›´æŽ¥ï¼š

```
$ cd xv6-riscv-fall19
$ git checkout fs
```

# 1. Large files

è¿™å—æ˜¯è¦ç»™ inode å±‚å®žçŽ° doubly indirect block ã€‚

è¿™é‡Œæˆ‘ç®€è¿°ä¸€ä¸‹ xv6-rv çš„ inode å±‚æ¨¡åž‹ï¼š

åŽŸå§‹ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ª inode è¡¨ç¤ºä¸€ä¸ªæ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶æœ‰ 13 ä¸ª entry è¡¨ç¤ºå‰ 12 ä¸ª direct block åœ¨ç£ç›˜ä¸Šçš„ä½ç½®å’Œ 1 ä¸ª indirect block çš„ä½ç½®ã€‚
indirect block æœ‰ 1024 (block size) / 4 (uint) = 256 ä¸ª entryï¼Œè¡¨ç¤ºé™¤ 12 ä¸ª direct block ä»¥å¤–çš„ data blockã€‚è¿™æ ·æ¯ä¸ªæ–‡ä»¶æœ€å¤šæœ‰ 256 + 13 = 269 ä¸ª data blockï¼Œè¿˜æ˜¯å¤ªå°äº†ã€‚

doubly indirect block å³å®žçŽ°ä¸€ä¸ªé€šè¿‡ä¸¤ä¸ªä¸­é—´å±‚å¯»å€æ‰¾åˆ° data blockï¼Œæ•…å¯ä»¥æ‰©å±• 256 * 256 = 65536 ä¸ª data block ã€‚æ•…æ€»è®¡æ¯ä¸ªæ–‡ä»¶çš„æœ€å¤§å¤§å°è¾¾åˆ° 64.26MB ï¼ˆé€šè¿‡ç‰ºç‰²ä¸€ä¸ª direct block entryï¼‰ã€‚

å…³é”®ä»£ç åœ¨ `kernel/fs.c > bmap()` ä¸­ã€‚

```c
static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a, *a2;
  struct buf *bp, *bp2;

  if(bn < NDIRECT){
    if((addr = ip->addrs[bn]) == 0)
      ip->addrs[bn] = addr = balloc(ip->dev);
    return addr;
  }
  bn -= NDIRECT;

  if(bn < NINDIRECT){
    // Load indirect block, allocating if necessary.
    if((addr = ip->addrs[NDIRECT]) == 0)
      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
    bp = bread(ip->dev, addr);
    a = (uint*)bp->data;
    if((addr = a[bn]) == 0){
      a[bn] = addr = balloc(ip->dev);
      log_write(bp);
    }
    brelse(bp);
    return addr;
  }
  bn -= NINDIRECT;

  if(bn < NDOUBLE_INDIRECT) {
    uint bn_level_1 = bn / NINDIRECT;
    uint bn_level_2 = bn % NINDIRECT;
    // Load level-1 indirect block, allocating if necessary.
    if((addr = ip->addrs[NDIRECT + 1]) == 0)
      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
    
    bp = bread(ip->dev, addr);
    a = (uint*)bp->data;
    // Load level-2 indirect block, allocating if necessary.
    if((addr = a[bn_level_1]) == 0){
      a[bn_level_1] = addr = balloc(ip->dev);
      // level-1 indirect block modified, write back
      log_write(bp);
    }
    brelse(bp);

    bp2 = bread(ip->dev, addr);
    a2 = (uint*)bp2->data;
    // Load data block, allocating if necessary.
    if((addr = a2[bn_level_2]) == 0){
      a2[bn_level_2] = addr = balloc(ip->dev);
      // level-2 block modified, write back
      log_write(bp2);
    }
    brelse(bp2);
    return addr;
  }

  panic("bmap: out of range");
}
```

# 2. Symbolic links

è¿™ä¸ªæ˜¯ç»™ file å±‚å®žçŽ°ä¸€ä¸ªç®€å•çš„ symbolic linkï¼Œéœ€è¦æ³¨æ„è¢«é“¾æŽ¥çš„æ–‡ä»¶æœªå¿…å­˜åœ¨ï¼Œå¯ä»¥æŠŠè¿™ä¸ª path å­˜åˆ° symbolic link æ–‡ä»¶ä¸­ã€‚

å…³é”®ä»£ç åœ¨ `kernel/sysfile.c >> sys_open()` å’Œ `kernel/sysfile.c >> sys_symlink()`

```c
uint64
sys_open(void)
{
  char path[MAXPATH];
  int fd, omode;
  struct file *f;
  struct inode *ip;
  int n;

  if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)
    return -1;

  begin_op(ROOTDEV);

  if(omode & O_CREATE){
    ip = create(path, T_FILE, 0, 0);
    if(ip == 0){
      end_op(ROOTDEV);
      return -1;
    }
  } else {
    if((ip = namei(path)) == 0){
      end_op(ROOTDEV);
      return -1;
    }
    ilock(ip);
    if(ip->type == T_DIR && omode != O_RDONLY){
      iunlockput(ip);
      end_op(ROOTDEV);
      return -1;
    }
  }

  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
    iunlockput(ip);
    end_op(ROOTDEV);
    return -1;
  }

  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
    if(f)
      fileclose(f);
    iunlockput(ip);
    end_op(ROOTDEV);
    return -1;
  }

  // printf("open: path=%s; no_follow=%d\n", path, !!(omode & O_NOFOLLOW));

  // resolve symlink
  if(!(omode & O_NOFOLLOW)) {
    uint cnt = 0;
    while(ip->type == T_SYMLINK && cnt < 10) {
      int len = 0;
      readi(ip, 0, (uint64)&len, 0, sizeof(int));
      
      if(len > MAXPATH)
        panic("open: corrupted symlink inode");
      
      readi(ip, 0, (uint64)path, sizeof(int), len + 1);
      iunlockput(ip);

      if((ip = namei(path)) == 0){
        end_op(ROOTDEV);
        return -1;
      }

      ilock(ip);
      
      if(ip->type == T_DIR && omode != O_RDONLY){
        iunlockput(ip);
        end_op(ROOTDEV);
        return -1;
      }

      if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
        iunlockput(ip);
        end_op(ROOTDEV);
        return -1;
      }

      // printf("open: resolve symlink -> %s len=%d\n", path, len);

      cnt++;
    }

    if(cnt >= 10) {
      iunlockput(ip);
      end_op(ROOTDEV);
      return -1;
    }
  }

  if(ip->type == T_DEVICE){
    f->type = FD_DEVICE;
    f->major = ip->major;
    f->minor = ip->minor;
  } else {
    f->type = FD_INODE;
  }
  f->ip = ip;
  f->off = 0;
  f->readable = !(omode & O_WRONLY);
  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);

  iunlock(ip);
  end_op(ROOTDEV);

  return fd;
}
```

```c
uint64 sys_symlink(void) {
  char target[MAXPATH], path[MAXPATH];
  int fd;
  struct file *f;
  struct inode *ip;

  if(argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0)
    return -1;
  
  begin_op(ROOTDEV);

  // Create symlink inode
  ip = create(path, T_SYMLINK, 0, 0);
  if(ip == 0){
    end_op(ROOTDEV);
    return -1;
  }

  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
    if(f)
      fileclose(f);
    iunlockput(ip);
    end_op(ROOTDEV);
    return -1;
  }

  f->type = FD_INODE;
  f->ip = ip;
  f->off = 0;
  f->readable = 0;
  f->writable = 0;

  int len = strlen(target);
  // printf("symlink: symlink %s -> %s len=%d\n", path, target, len);
  writei(ip, 0, (uint64)&len, 0, sizeof(int));
  writei(ip, 0, (uint64)target, sizeof(int), len + 1);
  iupdate(ip);
  iunlockput(ip);

  end_op(ROOTDEV);

  return 0;
}
```
